<!DOCTYPE html>
<html>
<head>
  <title>Basic 3D World</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel="stylesheet" type="text/css" href="base.css">
</head>

<body>
    <script id="boxVertexShader", type="x-shader/x-vertex">
        in vec3 position;

        uniform mat4 modelMatrix;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        uniform vec3 cameraPos;

        out vec3 vOrigin;
        out vec3 vDirection;

        void main() {
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;
            vDirection = position - vOrigin;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script id="boxFragmentShader", type="x-shader/x-fragment">
        precision highp float;
        precision highp sampler3D;

        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;

        in vec3 vOrigin;
        in vec3 vDirection;

        out vec4 color;

        uniform sampler3D map;
        uniform float threshold;
        uniform float steps;

        vec2 hitBox( vec3 orig, vec3 dir ) {
            const vec3 box_min = vec3( - 0.5 );
            const vec3 box_max = vec3( 0.5 );
            vec3 inv_dir = 1.0 / dir;
            vec3 tmin_tmp = ( box_min - orig ) * inv_dir;
            vec3 tmax_tmp = ( box_max - orig ) * inv_dir;
            vec3 tmin = min( tmin_tmp, tmax_tmp );
            vec3 tmax = max( tmin_tmp, tmax_tmp );
            float t0 = max( tmin.x, max( tmin.y, tmin.z ) );
            float t1 = min( tmax.x, min( tmax.y, tmax.z ) );
            return vec2( t0, t1 );
        }

        float sample1( vec3 p ) {
            return texture( map, p ).r;
        }

        #define epsilon .0001

        vec3 normal( vec3 coord ) {
            if ( coord.x < epsilon ) return vec3( 1.0, 0.0, 0.0 );
            if ( coord.y < epsilon ) return vec3( 0.0, 1.0, 0.0 );
            if ( coord.z < epsilon ) return vec3( 0.0, 0.0, 1.0 );
            if ( coord.x > 1.0 - epsilon ) return vec3( - 1.0, 0.0, 0.0 );
            if ( coord.y > 1.0 - epsilon ) return vec3( 0.0, - 1.0, 0.0 );
            if ( coord.z > 1.0 - epsilon ) return vec3( 0.0, 0.0, - 1.0 );
            float step = 0.01;
            float x = sample1( coord + vec3( - step, 0.0, 0.0 ) ) - sample1( coord + vec3( step, 0.0, 0.0 ) );
            float y = sample1( coord + vec3( 0.0, - step, 0.0 ) ) - sample1( coord + vec3( 0.0, step, 0.0 ) );
            float z = sample1( coord + vec3( 0.0, 0.0, - step ) ) - sample1( coord + vec3( 0.0, 0.0, step ) );
            return normalize( vec3( x, y, z ) );
        }
        
        void main(){
            vec3 rayDir = normalize( vDirection );
            vec2 bounds = hitBox( vOrigin, rayDir );
            if ( bounds.x > bounds.y ) discard;
            bounds.x = max( bounds.x, 0.0 );
            vec3 p = vOrigin + bounds.x * rayDir;
            vec3 inc = 1.0 / abs( rayDir );
            float delta = min( inc.x, min( inc.y, inc.z ) );
            delta /= steps;
            for ( float t = bounds.x; t < bounds.y; t += delta ) {
                float d = sample1( p + 0.5 );
                if ( d > threshold ) {
                    color.rgb = normal( p + 0.5 ) * 0.5 + ( p * 1.5 + 0.25 );
                    color.a = 1.;
                    break;
                }
                p += rayDir * delta;
            }
            if ( color.a == 0.0 ) discard;
        }
    </script>




    <script id="vertexShader", type="x-shader/x-vertex">
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="fragmentShader", type="x-shader/x-fragment">
        uniform sampler2D textureMap;
        
        void main() {
            vec2 invRes = vec2(1.0, 1.0) / vec2(4096.0, 64.0);
            vec2 uv = gl_FragCoord.xy * invRes;

            vec4 textureValue = texture2D(textureMap, uv);

            if (textureValue.z > 0.0) {
                gl_FragColor = vec4(0.4);
            }
            else {
                float output_color = length(textureValue.xy) * 0.008;
                gl_FragColor = vec4(vec3(output_color), 1.0);
            }
            //gl_FragColor = vec4(textureValue.xyz * 0.01, 1) ;
            
        }
    </script>
    <script id="advectShader", type="x-shader/x-fragment">
        uniform float timestep;
        uniform sampler2D temperatureSampler;

        uniform float b; // represents the buoyancy constant
        uniform float inv_T_zero; // inverse of T_0, the ambient room temperature.
        uniform vec3 blockRes;

        const vec3 Force = vec3(0.0, 100.0, 0.0);
        const vec3 ForceAreaMin = vec3(0.4, 0.0, 0.4);
        const vec3 ForceAreaMax = vec3(0.6, 0.06, 0.6);

        const vec3 BarrierPosition = vec3(0.5, 0.2, 0.2);
        const float BarrierRadiusSq = 0.01;

        vec4 getTex3D(sampler2D map, vec3 xyz) {
            vec2 uv1 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.z) * blockRes.z;
            return vec3(x_coord, xy.y, xy.x / blockRes.z);
        }

        vec3 buoyancyForce(vec2 pos) {
            float temperature = texture2D(temperatureSampler, pos).x;
            if (temperature == 0.0) {
                return vec3(0.0);
            }
            return b * (inv_T_zero - (1.0 / temperature)) * vec3(0.0, 1.0, 0.0);
        }

        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz * invBlockRes;

            vec3 oldVelocity = texture2D(velocityOutputSampler, uv).xyz;
            vec3 uvwOld = uvw - oldVelocity * timestep * invBlockRes;
            vec3 outputVelocity = getTex3D(velocityOutputSampler, uvwOld).xyz;

            if (uvw.x > ForceAreaMin.x && uvw.x < ForceAreaMax.x && 
                uvw.y > ForceAreaMin.y && uvw.y < ForceAreaMax.y &&
                uvw.z > ForceAreaMin.z && uvw.z < ForceAreaMax.z
            ) 
            {
                outputVelocity += Force * timestep;
            }

            outputVelocity += buoyancyForce(uv);

            if (uv.x > 1.0 - invRes.x || uv.x < invRes.x ||
                uv.y > 1.0 - invRes.y || uv.y < invRes.y) 
            {
                outputVelocity = vec3(0.0, 0.0, 0.0);
            }

            vec3 toBarrier = BarrierPosition - uvw;
            //toBarrier.x *= invRes.y / invRes.x;

            if (dot(toBarrier, toBarrier) < BarrierRadiusSq) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 999.0);
            }
            else {
                gl_FragColor = vec4(outputVelocity, 0.0);
            }
        }
    </script>

    <script id="temperatureShader", type="x-shader/x-fragment">
        uniform float timestep;

        uniform vec3 blockRes;
        const vec3 HeatAreaMin = vec3(0.4, 0.0, 0.4);
        const vec3 HeatAreaMax = vec3(0.6, 0.06, 0.6);

        float HeatAreaTemp = 100.0;

        vec4 getTex3D(sampler2D map, vec3 xyz) {
            vec2 uv1 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.z) * blockRes.z;
            return vec3(x_coord, xy.y, xy.x / blockRes.z);
        }


        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz / blockRes;

            vec3 oldVelocity = texture2D(velocityOutputSampler, uv).xyz;
            vec3 uvwOld = uvw - oldVelocity * timestep * invBlockRes;
            float temperature = getTex3D(temperatureSampler, uvwOld).x;

            if (uvw.x > HeatAreaMin.x && uvw.x < HeatAreaMax.x && 
                uvw.y > HeatAreaMin.y && uvw.y < HeatAreaMax.y &&
                uvw.z > HeatAreaMin.y && uvw.z < HeatAreaMax.y
            ) 
            {
                temperature = HeatAreaTemp;
            }

            gl_FragColor = vec4(temperature);
        }

    </script>

    <script id="divergenceShader", type="x-shader/x-fragment">
        uniform sampler2D velocitySampler;

        uniform vec3 blockRes;

        vec4 getTex3D(sampler2D map, vec3 xyz) {
            vec2 uv1 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.z) * blockRes.z;
            return vec3(x_coord, xy.y, xy.x / blockRes.z);
        }


        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            if (texture2D(velocitySampler, uv).w > 0.0) {
                gl_FragColor = vec4(0.0);
                return;
            }

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz * invBlockRes;

            float x0 = getTex3D(velocitySampler, uvw - vec3(invBlockRes.x, 0, 0)).x;
            float x1 = getTex3D(velocitySampler, uvw + vec3(invBlockRes.x, 0, 0)).x;
            float y0 = getTex3D(velocitySampler, uvw - vec3(0, invBlockRes.y, 0)).y;
            float y1 = getTex3D(velocitySampler, uvw + vec3(0, invBlockRes.y, 0)).y;
            float z0 = getTex3D(velocitySampler, uvw - vec3(0, 0, invBlockRes.z)).z;
            float z1 = getTex3D(velocitySampler, uvw + vec3(0, 0, invBlockRes.z)).z;

            float divergence = ((x1 - x0) + (y1 - y0) + (z1 - z0)) * 0.5;
            gl_FragColor = vec4(divergence);
        }
    </script>

    <script id="jacobiShader", type="x-shader/x-fragment">
        uniform sampler2D velocitySampler;
        uniform sampler2D divergenceSampler;

        uniform vec3 blockRes;

        vec4 getTex3D(sampler2D map, vec3 xyz) {
            vec2 uv1 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.z) * blockRes.z;
            return vec3(x_coord, xy.y, xy.x / blockRes.z);
        }


        float samplePressure(vec3 pos, vec2 uv) {
            vec3 border = 2.0 * vec3(1.0, 1.0, 1.0) / blockRes;

            if (texture2D(velocitySampler, uv).z > 0.0) {
                return 0.0;
            }

            if (pos.x > 1.0 - border.x || pos.y > 1.0 - border.y || pos.z > 1.0 - border.z || 
                pos.x < border.x || pos.y < border.y || pos.z < border.z) 
            {
                return 0.0;
            } 
            else {
                return getTex3D(pressureSampler, pos).x;
            }
        }

        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz * invBlockRes;

            float div = getTex3D(divergenceSampler, uvw).x;
            float x0 = samplePressure(uvw - vec3(invBlockRes.x, 0, 0), uv);
            float x1 = samplePressure(uvw + vec3(invBlockRes.x, 0, 0), uv);
            float y0 = samplePressure(uvw - vec3(0, invBlockRes.y, 0), uv);
            float y1 = samplePressure(uvw + vec3(0, invBlockRes.y, 0), uv);
            float z0 = samplePressure(uvw - vec3(0, 0, invBlockRes.z), uv);
            float z1 = samplePressure(uvw + vec3(0, 0, invBlockRes.z), uv);

            float jacobiOutput = (x0 + x1 + y0 + y1 + z0 + z1 - div) / 6.0;
            gl_FragColor = vec4(jacobiOutput);
        }
    </script>

    <script id="outputShader", type="x-shader/x-fragment">
        uniform sampler2D velocitySampler;
        uniform sampler2D pressureSampler;

        uniform vec3 blockRes;

        vec4 getTex3D(sampler2D map, vec3 xyz) {
            vec2 uv1 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + floor(xyz.z) * blockRes.x, xyz.y);
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.z) * blockRes.z;
            return vec3(x_coord, xy.y, xy.x / blockRes.z);
        }

        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz * invBlockRes;

            float x0 = getTex3D(pressureSampler, uvw - vec3(invBlockRes.x, 0, 0)).x;
            float x1 = getTex3D(pressureSampler, uvw + vec3(invBlockRes.x, 0, 0)).x;
            float y0 = getTex3D(pressureSampler, uvw - vec3(0, invBlockRes.y, 0)).x;
            float y1 = getTex3D(pressureSampler, uvw + vec3(0, invBlockRes.y, 0)).x;
            float z0 = getTex3D(pressureSampler, uvw - vec3(0, 0, invBlockRes.z)).x;
            float z1 = getTex3D(pressureSampler, uvw + vec3(0, 0, invBlockRes.z)).x;

            vec3 pressureGradient = (vec3(x1, y1, z1) - vec3(x0, y0, z0)) * 0.5;
            vec3 oldV = texture2D(velocitySampler, uv).xyz;


            gl_FragColor = vec4(oldV - pressureGradient, 1.0);
        }
    </script>
	<script src="./fluid_main.js?2"  type="module"></script>

</body>
</html>
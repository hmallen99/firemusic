<!DOCTYPE html>
<html>
<head>
  <title>Basic 3D World</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <link rel="stylesheet" type="text/css" href="base.css">
</head>

<body>
    <script id="boxVertexShader", type="x-shader/x-vertex">
        in vec3 position;

        uniform mat4 modelMatrix;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        uniform vec3 cameraPos;

        out vec3 vOrigin;
        out vec3 vDirection;

        void main() {
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            vOrigin = vec3( inverse( modelMatrix ) * vec4( cameraPos, 1.0 ) ).xyz;
            vDirection = position - vOrigin;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script id="boxFragmentShader", type="x-shader/x-fragment">
        precision highp float;
        precision highp sampler2D;

        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;

        in vec3 vOrigin;
        in vec3 vDirection;

        out vec4 color;

        uniform sampler2D map;
        uniform float threshold;
        uniform float steps;

        vec2 hitBox( vec3 orig, vec3 dir ) {
            const vec3 box_min = vec3( - 0.5 );
            const vec3 box_max = vec3( 0.5 );
            vec3 inv_dir = 1.0 / dir;
            vec3 tmin_tmp = ( box_min - orig ) * inv_dir;
            vec3 tmax_tmp = ( box_max - orig ) * inv_dir;
            vec3 tmin = min( tmin_tmp, tmax_tmp );
            vec3 tmax = max( tmin_tmp, tmax_tmp );
            float t0 = max( tmin.x, max( tmin.y, tmin.z ) );
            float t1 = min( tmax.x, min( tmax.y, tmax.z ) );
            return vec2( t0, t1 );
        }

        vec4 getTex3D(sampler2D map, vec3 uvw) {
            vec3 blockRes = vec3(64.0, 64.0, 64.0);
            vec3 xyz = uvw * blockRes;
            vec2 invRes = vec2(1.0, 1.0) / vec2(4096.0, 64.0);
            float z_part = xyz.z - mod(xyz.z, 1.0);
            vec2 uv1 = vec2(xyz.x + z_part * blockRes.x , xyz.y) * invRes;
            vec4 color1 = texture(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + (z_part + 1.0) * blockRes.x, xyz.y) * invRes;
            vec4 color2 = texture(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        }

        vec4 sample4(vec3 p) {
            vec4 texColor = getTex3D( map, p );
            if (texColor.w > 0.0) {
                return vec4(0, 0, 0, 999.9);
            }
            return vec4(texColor.rgb * 0.002, 0.0);
        }
        
        void main(){
            vec3 rayDir = normalize( vDirection );
            vec2 bounds = hitBox( vOrigin, rayDir );
            if ( bounds.x > bounds.y ) discard;
            bounds.x = max( bounds.x, 0.0 );
            vec3 p = vOrigin + bounds.x * rayDir;
            vec3 inc = 1.0 / abs( rayDir );
            float delta = min( inc.x, min( inc.y, inc.z ) );
            delta /= steps;
            for ( float t = bounds.x; t < bounds.y; t += delta ) {
                vec4 d = sample4(p + 0.5);
                if (d.w > 0.0) {
                    color.rgb = max(color.rgb, vec3(0.4));
                    color.a = 1.;
                    break;
                }
                color.rgb += vec3(length(d.rgb));
                color.a = 1.;
                if ( length(color.rgb) >  1.0) {
                    break;
                }
                p += rayDir * delta;
            }
            if ( color.a == 0.0 ) discard;
        }
    </script>

    <script id="advectShader", type="x-shader/x-fragment">
        uniform float timestep;
        uniform sampler2D temperatureSampler;

        uniform float b; // represents the buoyancy constant
        uniform float inv_T_zero; // inverse of T_0, the ambient room temperature.
        uniform vec3 blockRes;

        const vec3 Force = vec3(0.0, 100.0, 0.0);
        const vec3 ForceAreaMin = vec3(0.4, 0.0, 0.4);
        const vec3 ForceAreaMax = vec3(0.6, 0.06, 0.6);

        const vec3 BarrierPosition = vec3(0.5, 0.2, 0.5);
        const float BarrierRadiusSq = 0.01;

        vec4 getTex3D(sampler2D map, vec3 uvw) {
            vec3 xyz = uvw * blockRes;
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            float z_part = xyz.z - mod(xyz.z, 1.0);
            vec2 uv1 = vec2(xyz.x + z_part * blockRes.x , xyz.y) * invRes;
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + (z_part + 1.0) * blockRes.x, xyz.y) * invRes;
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.x) * blockRes.x;
            return vec3(x_coord, xy.y, floor(xy.x / blockRes.x));
        }

        vec3 buoyancyForce(vec2 pos) {
            float temperature = texture2D(temperatureSampler, pos).x;
            if (temperature == 0.0) {
                return vec3(0.0);
            }
            return b * (inv_T_zero - (1.0 / temperature)) * vec3(0.0, 1.0, 0.0);
        }

        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz * invBlockRes;

            vec3 oldVelocity = texture2D(velocityOutputSampler, uv).xyz;
            vec3 uvwOld = uvw - oldVelocity * timestep * invBlockRes;
            vec3 outputVelocity = getTex3D(velocityOutputSampler, uvwOld).xyz;

            if (uvw.x > ForceAreaMin.x && uvw.x < ForceAreaMax.x && 
                uvw.y > ForceAreaMin.y && uvw.y < ForceAreaMax.y &&
                uvw.z > ForceAreaMin.z && uvw.z < ForceAreaMax.z
            ) 
            {
                outputVelocity += Force * timestep;
            }

            outputVelocity += buoyancyForce(uv);

            if (uvw.x > 1.0 - invBlockRes.x || uvw.x < invBlockRes.x ||
                uvw.y > 1.0 - invBlockRes.y || uvw.y < invBlockRes.y ||
                uvw.z > 1.0 - invBlockRes.z || uvw.z < invBlockRes.z
            )  
            {
                outputVelocity = vec3(0.0, 0.0, 0.0);
            }

            vec3 toBarrier = BarrierPosition - uvw;
            //toBarrier.x *= invRes.y / invRes.x;

            if (dot(toBarrier, toBarrier) < BarrierRadiusSq) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 999.0);
            }
            else {
                gl_FragColor = vec4(outputVelocity, 0.0);
            }
        }
    </script>

    <script id="temperatureShader", type="x-shader/x-fragment">
        uniform float timestep;

        uniform vec3 blockRes;
        const vec3 HeatAreaMin = vec3(0.4, 0.0, 0.4);
        const vec3 HeatAreaMax = vec3(0.6, 0.06, 0.6);

        float HeatAreaTemp = 100.0;

        vec4 getTex3D(sampler2D map, vec3 uvw) {
            vec3 xyz = uvw * blockRes;
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            float z_part = xyz.z - mod(xyz.z, 1.0);
            vec2 uv1 = vec2(xyz.x + z_part * blockRes.x , xyz.y) * invRes;
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + (z_part + 1.0) * blockRes.x, xyz.y) * invRes;
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.x) * blockRes.x;
            return vec3(x_coord, xy.y, floor(xy.x / blockRes.x));
        }


        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz / blockRes;

            vec3 oldVelocity = texture2D(velocityOutputSampler, uv).xyz;
            vec3 uvwOld = uvw - oldVelocity * timestep * invBlockRes;
            float temperature = getTex3D(temperatureSampler, uvwOld).x;

            if (uvw.x > HeatAreaMin.x && uvw.x < HeatAreaMax.x && 
                uvw.y > HeatAreaMin.y && uvw.y < HeatAreaMax.y &&
                uvw.z > HeatAreaMin.y && uvw.z < HeatAreaMax.y
            ) 
            {
                temperature = HeatAreaTemp;
            }

            gl_FragColor = vec4(temperature);
        }

    </script>

    <script id="divergenceShader", type="x-shader/x-fragment">
        uniform sampler2D velocitySampler;

        uniform vec3 blockRes;

        vec4 getTex3D(sampler2D map, vec3 uvw) {
            vec3 xyz = uvw * blockRes;
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            float z_part = xyz.z - mod(xyz.z, 1.0);
            vec2 uv1 = vec2(xyz.x + z_part * blockRes.x , xyz.y) * invRes;
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + (z_part + 1.0) * blockRes.x, xyz.y) * invRes;
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.x) * blockRes.x;
            return vec3(x_coord, xy.y, floor(xy.x / blockRes.x));
        }


        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            if (texture2D(velocitySampler, uv).w > 0.0) {
                gl_FragColor = vec4(0.0);
                return;
            }

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz * invBlockRes;

            float x0 = getTex3D(velocitySampler, uvw - vec3(invBlockRes.x, 0, 0)).x;
            float x1 = getTex3D(velocitySampler, uvw + vec3(invBlockRes.x, 0, 0)).x;
            float y0 = getTex3D(velocitySampler, uvw - vec3(0, invBlockRes.y, 0)).y;
            float y1 = getTex3D(velocitySampler, uvw + vec3(0, invBlockRes.y, 0)).y;
            float z0 = getTex3D(velocitySampler, uvw - vec3(0, 0, invBlockRes.z)).z;
            float z1 = getTex3D(velocitySampler, uvw + vec3(0, 0, invBlockRes.z)).z;

            float divergence = ((x1 - x0) + (y1 - y0) + (z1 - z0)) * 0.5;
            gl_FragColor = vec4(divergence);
        }
    </script>

    <script id="jacobiShader", type="x-shader/x-fragment">
        uniform sampler2D velocitySampler;
        uniform sampler2D divergenceSampler;

        uniform vec3 blockRes;

        vec4 getTex3D(sampler2D map, vec3 uvw) {
            vec3 xyz = uvw * blockRes;
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            float z_part = xyz.z - mod(xyz.z, 1.0);
            vec2 uv1 = vec2(xyz.x + z_part * blockRes.x , xyz.y) * invRes;
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + (z_part + 1.0) * blockRes.x, xyz.y) * invRes;
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.x) * blockRes.x;
            return vec3(x_coord, xy.y, floor(xy.x / blockRes.x));
        }


        float samplePressure(vec3 pos, vec2 uv) {
            vec3 border = 2.0 * vec3(1.0, 1.0, 1.0) / blockRes;

            if (texture2D(velocitySampler, uv).z > 0.0) {
                return 0.0;
            }

            if (pos.x > 1.0 - border.x || pos.y > 1.0 - border.y || pos.z > 1.0 - border.z || 
                pos.x < border.x || pos.y < border.y || pos.z < border.z) 
            {
                return 0.0;
            } 
            else {
                return getTex3D(pressureSampler, pos).x;
            }
        }

        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz * invBlockRes;

            float div = getTex3D(divergenceSampler, uvw).x;
            float x0 = samplePressure(uvw - vec3(invBlockRes.x, 0, 0), uv);
            float x1 = samplePressure(uvw + vec3(invBlockRes.x, 0, 0), uv);
            float y0 = samplePressure(uvw - vec3(0, invBlockRes.y, 0), uv);
            float y1 = samplePressure(uvw + vec3(0, invBlockRes.y, 0), uv);
            float z0 = samplePressure(uvw - vec3(0, 0, invBlockRes.z), uv);
            float z1 = samplePressure(uvw + vec3(0, 0, invBlockRes.z), uv);

            float jacobiOutput = (x0 + x1 + y0 + y1 + z0 + z1 - div) / 6.0;
            gl_FragColor = vec4(jacobiOutput);
        }
    </script>

    <script id="outputShader", type="x-shader/x-fragment">
        uniform sampler2D velocitySampler;
        uniform sampler2D pressureSampler;

        uniform vec3 blockRes;

        vec4 getTex3D(sampler2D map, vec3 uvw) {
            vec3 xyz = uvw * blockRes;
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            float z_part = xyz.z - mod(xyz.z, 1.0);
            vec2 uv1 = vec2(xyz.x + z_part * blockRes.x , xyz.y) * invRes;
            vec4 color1 = texture2D(map, uv1);
        
            vec2 uv2 = vec2(xyz.x + (z_part + 1.0) * blockRes.x, xyz.y) * invRes;
            vec4 color2 = texture2D(map, uv2);
        
            float t = xyz.z - floor(xyz.z);
            return (1.0 - t) * color1 + t * color2;
        }

        vec3 getXYZ(vec2 xy) {
            float x_coord = xy.x - floor(xy.x / blockRes.x) * blockRes.x;
            return vec3(x_coord, xy.y, floor(xy.x / blockRes.x));
        }

        void main() {
            vec2 invRes = vec2(1.0, 1.0) / resolution.xy;
            vec2 uv = gl_FragCoord.xy * invRes;

            vec3 invBlockRes = vec3(1.0, 1.0, 1.0) / blockRes;
            vec3 xyz = getXYZ(gl_FragCoord.xy);
            vec3 uvw = xyz * invBlockRes;

            float x0 = getTex3D(pressureSampler, uvw - vec3(invBlockRes.x, 0, 0)).x;
            float x1 = getTex3D(pressureSampler, uvw + vec3(invBlockRes.x, 0, 0)).x;
            float y0 = getTex3D(pressureSampler, uvw - vec3(0, invBlockRes.y, 0)).x;
            float y1 = getTex3D(pressureSampler, uvw + vec3(0, invBlockRes.y, 0)).x;
            float z0 = getTex3D(pressureSampler, uvw - vec3(0, 0, invBlockRes.z)).x;
            float z1 = getTex3D(pressureSampler, uvw + vec3(0, 0, invBlockRes.z)).x;

            vec3 pressureGradient = (vec3(x1, y1, z1) - vec3(x0, y0, z0)) * 0.5;
            vec3 oldV = texture2D(velocitySampler, uv).xyz;


            gl_FragColor = vec4(oldV - pressureGradient, 1.0);
            //gl_FragColor = vec4(oldV, 1.0);
        }
    </script>

	<div id="content">
    
        <label for="thefile" class="file" style="color:white;"> Choose an audio file
          <input type="file" id="thefile" accept="audio/*" />
        </label>
    
        <audio id="audio" controls></audio>
        <div id="out"></div>
    </div>
    <script src="./main.js" type="module">
    </script>

</body>
</html>